# Звіт про надійність

### Проблема №1 — *(b)Відсутні health-check і таймаути БД*

**Місце в коді:**  
<src/api/db.py>
**приклад проблемного коду**
   ```python
   engine = create_engine(DATABASE_URL)
   ```
**Пояснення чому небезпечна**  
Без `pool_pre_ping` і таймаутів запити можуть зависати 

**Потенційний вплив**
Зависання сервісу, каскадні збої


### Проблема №2 — *(a)Ковтання помилок бд мовчки*

**Місце в коді:**  
<src/api/services/user_service.py> 
**приклад проблемного коду**
```python
def get_user_by_id(session, user_id):
    try:
        return session.query(User).get(user_id)
    except SQLAlchemyError as e:
        print(f"Database error fetching user {user_id}: {e}")
        return None
   ```
**Пояснення чому небезпечна** 
бо помилка вважається коректним результатом, і нічого не логується

**Потенційний вплив**
неможливо діагностувати збій, система поводиться ніби все працює


### Проблема №3 — *(с) слабка валідація на рівні сервісів*

**Місце в коді:**  
<src/api/services/user_service.py> 
**приклад проблемного коду**
```python
email = data.get("email")
# не перевіряється, чи email не None/порожній
   ```

**Пояснення чому небезпечна** 
Якщо цей сервіс викликається поза API-шаром, може впасти з IntegrityError.


**Потенційний вплив**
помилки, складне тестування, можна вирішити додавши локальну валідацію та кидати ValueError("Invalid email")

### Проблема №4 — *(a) Обробка помилок (занадто широке перехоплення (except Exception)*

**Місце в коді:**  
</routes> 
```python
Exception as e:
```
**Пояснення чому небезпечна** 
Перехоплює всі можливі помилки, у т.ч. системні або логічні, які потрібно обробляти окремо


**Потенційний вплив**
Приховування реальних причин збоїв, складність у відлагодженні, ризик пропустити критичну помилку

### Проблема №5 — *(d) Повернення None / 404 без логування*

**Місце в коді:**  
<src/api/routes/users.py> 
```python
|if not user:
            abort(404, message="User not found")
        return user
   ```

**Пояснення чому небезпечна** 
Немає логів, які б пояснювали, чому користувача не знайдено.


**Потенційний вплив**
Втрата розуміння як виправити швидко помилку.



### Проблема №6 — *(a) Витік внутрішніх деталей у повідомленнях користувачу*

**Місце в коді:**  
</routes> 
```python
abort(500, message=str(e))
   ```

**Пояснення чому небезпечна** 
Повідомлення str(e) може містити внутрішню інформацію


**Потенційний вплив**
Розкриття внутрішньої структури серверу для всіх

### Проблема №7 — *(е) Відсутність перевірки JSON у вхідних запитах*

**Місце в коді:**  
<src/api/routes/auth_routes.py> 
**приклад проблемного коду**
```python
data = request.get_json()
```
**Пояснення чому небезпечна** 
Якщо JSON пошкоджено, піднімається BadRequest, який не обробляється

**Потенційний вплив**
500 Internal Server Error при помилці клієнта , вирішити так : data = request.get_json(silent=True) і валідація if data is None: abort(400, ...).

### Проблема №8 — *Повернення None або False замість явної помилки*
**Місце в коді:**  
<src/api/services/room_service.py>
```python
def delete_room(...):
    room = session.query(Room).get(room_id)
    if not room:
        return False
```
**Пояснення чому небезпечна** 
Код, який викликає цю функцію, може неправильно інтерпретувати False як успішне видалення.

**Потенційний вплив**
Дані не видаляються, але система поводиться ніби успіх.


### Проблема №9 — *Виклики зовнішніх API без таймаутів*

**Місце в коді:**  
<src/api/services/payment_service.py> 
**приклад проблемного коду**
```python
data = request.get_json()
```
**Пояснення чому небезпечна** 
Якщо сторонній API зависне, сервер очікує без обмеження часу.

**Потенційний вплив**
Перевантаження потоків, зниження продуктивності вирішення: requests.post(API_URL, json=data, timeout=10) і обробка requests.Timeout.

### Проблема №10 — *(е) Використання небезпечного псевдовипадкового генератора для створення коду бронювання*

**Місце в коді:**  
<src/api/services/booking_service.py> 
**приклад проблемного коду**
```python
def generate_booking_code():
    timestamp = int(time.time() * 1000) % 1000000
    random_part = random.randint(10000, 99999)

    return f"BK{timestamp}{random_part}"
```    
**Пояснення чому небезпечна** 
Модуль random не є криптографічно стійким — значення можна передбачити, особливо якщо відомо час створення (timestamp).

**Потенційний вплив**
Можливість передбачити або підробити booking code => ризик несанкціонованого доступу, дублювання або зміни бронювання.