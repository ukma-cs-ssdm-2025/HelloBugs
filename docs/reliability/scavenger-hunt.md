# Звіт про надійність

### Проблема №1 — *(b)Відсутні health-check і таймаути БД*

**Місце в коді:**  
<src/api/db.py>
**приклад проблемного коду**
   ```python
   engine = create_engine(DATABASE_URL)
   ```
**Пояснення чому небезпечна**  
Без `pool_pre_ping` і таймаутів запити можуть зависати 

**Потенційний вплив**
Зависання сервісу, каскадні збої

| Поле | Пояснення |
|---|---|
| **Fault (Джерело дефекту)** | `create_engine(DATABASE_URL)` використовується без параметрів `pool_pre_ping`, таймаутів або health-check-логіки. |
| **Error (Некоректний внутрішній стан)** | Підключення до БД можуть “зависати” або залишатись неактивними; пул з’єднань блокується. |
| **Failure (Неправильна зовнішня поведінка)** | Запити сервісу зависають або не завершуються; інші сервіси теж починають відмовляти через каскадний ефект. |
| **Severity (Критичність)** | Висока |


### Проблема №2 — *(a)Ковтання помилок бд мовчки*

**Місце в коді:**  
<src/api/services/user_service.py> 
**приклад проблемного коду**
```python
def get_user_by_id(session, user_id):
    try:
        return session.query(User).get(user_id)
    except SQLAlchemyError as e:
        print(f"Database error fetching user {user_id}: {e}")
        return None
   ```
**Пояснення чому небезпечна** 
бо помилка вважається коректним результатом, і нічого не логується

**Потенційний вплив**
неможливо діагностувати збій, система поводиться ніби все працює

| Поле | Пояснення |
|---|---|
| **Fault** | У блоці `try/except SQLAlchemyError` помилка лише друкується через `print(...)` і повертається `None`, без логування чи повторного підняття. |
| **Error** | Реальні помилки БД губляться; виклик повертає `None`, що може трактуватись як «коректна відсутність користувача». |
| **Failure** | Неможливо діагностувати збій; система поводиться ніби все добре, хоча запит до БД завершився з помилкою. |
| **Severity** | Висока |


### Проблема №3 — *(с) слабка валідація на рівні сервісів*

**Місце в коді:**  
<src/api/services/user_service.py> 
**приклад проблемного коду**
```python
email = data.get("email")
# не перевіряється, чи email не None/порожній
   ```

**Пояснення чому небезпечна** 
Якщо цей сервіс викликається поза API-шаром, може впасти з IntegrityError.


**Потенційний вплив**
помилки, складне тестування, можна вирішити додавши локальну валідацію та кидати ValueError("Invalid email")

| Поле | Пояснення |
|---|---|
| **Fault** | `email = data.get("email")` — відсутня перевірка на `None`, порожній рядок або некоректний формат. |
| **Error** | Некоректні або порожні значення передаються далі у бізнес-логіку або базу даних. |
| **Failure** | Може виникати `IntegrityError` або падіння при виклику сервісу поза API-шаром; важче тестувати систему. |
| **Severity** | Середня |

### Проблема №4 — *(a) Обробка помилок (занадто широке перехоплення (except Exception)*

**Місце в коді:**  
</routes> 
```python
Exception as e:
```
**Пояснення чому небезпечна** 
Перехоплює всі можливі помилки, у т.ч. системні або логічні, які потрібно обробляти окремо


**Потенційний вплив**
Приховування реальних причин збоїв, складність у відлагодженні, ризик пропустити критичну помилку

| Поле | Пояснення |
|---|---|
| **Fault** | Використовується `except Exception` без конкретизації типу винятку. |
| **Error** | Всі типи помилок, включно з системними або логічними, перехоплюються разом і не обробляються належним чином. |
| **Failure** | Реальні причини збоїв приховуються; ускладнюється відлагодження; критичні помилки можуть бути проігноровані. |
| **Severity** | Висока |

### Проблема №5 — *(d) Повернення None / 404 без логування*

**Місце в коді:**  
<src/api/routes/users.py> 
```python
|if not user:
            abort(404, message="User not found")
        return user
   ```

**Пояснення чому небезпечна** 
Немає логів, які б пояснювали, чому користувача не знайдено.


**Потенційний вплив**
Втрата розуміння як виправити швидко помилку.

| Поле | Пояснення |
|---|---|
| **Fault** | `abort(404, message="User not found")` виконується без жодного логування або додаткового контексту. |
| **Error** | Відсутня інформація про те, чому користувач не знайдений, які параметри запиту були передані тощо. |
| **Failure** | Неможливо швидко зрозуміти причину 404-помилки; ускладнено пошук і виправлення дефектів. |
| **Severity** | Середня |


### Проблема №6 — *(a) Витік внутрішніх деталей у повідомленнях користувачу*

**Місце в коді:**  
</routes> 
```python
abort(500, message=str(e))
   ```

**Пояснення чому небезпечна** 
Повідомлення str(e) може містити внутрішню інформацію


**Потенційний вплив**
Розкриття внутрішньої структури серверу для всіх

| Поле | Пояснення |
|---|---|
| **Fault** | У відповідь користувачу передається `str(e)` -  сирий текст помилки без фільтрації. |
| **Error** | Внутрішні винятки стають видимими зовні; розкриваються деталі реалізації або структури БД. |
| **Failure** | Потенційний витік конфіденційної інформації, підвищення ризику цілеспрямованих атак. |
| **Severity** | Висока |


### Проблема №7 — *(е) Відсутність перевірки JSON у вхідних запитах*

**Місце в коді:**  
<src/api/routes/auth_routes.py> 
**приклад проблемного коду**
```python
data = request.get_json()
```
**Пояснення чому небезпечна** 
Якщо JSON пошкоджено, піднімається BadRequest, який не обробляється

**Потенційний вплив**
500 Internal Server Error при помилці клієнта , вирішити так : data = request.get_json(silent=True) і валідація if data is None: abort(400, ...).

| Поле | Пояснення |
|---|---|
| **Fault** | Виклик `request.get_json()` без `silent=True` та без перевірки `if data is None`. |
| **Error** | При пошкодженому JSON виникає `BadRequest`, який не обробляється, або далі передається `None`. |
| **Failure** | Користувач отримує 500 Internal Server Error замість зрозумілої 400-помилки; сервіс виглядає нестабільним. |
| **Severity** | Середня |

### Проблема №8 — *Повернення None або False замість явної помилки*
**Місце в коді:**  
<src/api/services/room_service.py>
```python
def delete_room(...):
    room = session.query(Room).get(room_id)
    if not room:
        return False
```
**Пояснення чому небезпечна** 
Код, який викликає цю функцію, може неправильно інтерпретувати False як успішне видалення.

**Потенційний вплив**
Дані не видаляються, але система поводиться ніби успіх.

| Поле | Пояснення |
|---|---|
| **Fault** | Якщо кімнату не знайдено, функція повертає `False`, а не піднімає виняток чи спеціальний результат. |
| **Error** | Код, що викликає функцію, може неправильно інтерпретувати `False` як успішне видалення. |
| **Failure** | Дані залишаються незмінними, але система вважає, що операція пройшла успішно; спотворення стану. |
| **Severity** | Середня |


### Проблема №9 — *Виклики зовнішніх API без таймаутів*

**Місце в коді:**  
<src/api/services/payment_service.py> 
**приклад проблемного коду**
```python
data = request.get_json()
```
**Пояснення чому небезпечна** 
Якщо сторонній API зависне, сервер очікує без обмеження часу.

**Потенційний вплив**
Перевантаження потоків, зниження продуктивності вирішення: requests.post(API_URL, json=data, timeout=10) і обробка requests.Timeout.

| Поле | Пояснення |
|---|---|
| **Fault** | Виклик `requests.post(API_URL, json=data)` виконується без параметра `timeout` і без політики повторних спроб. |
| **Error** | Потоки або процеси блокуються в очікуванні відповіді від стороннього сервісу; ресурси не звільняються. |
| **Failure** | Зниження продуктивності, зависання системи при недоступності зовнішнього API, каскадні відмови. |
| **Severity** | Висока |

### Проблема №10 — *(е) Використання небезпечного псевдовипадкового генератора для створення коду бронювання*

**Місце в коді:**  
<src/api/services/booking_service.py> 
**приклад проблемного коду**
```python
def generate_booking_code():
    timestamp = int(time.time() * 1000) % 1000000
    random_part = random.randint(10000, 99999)

    return f"BK{timestamp}{random_part}"
```    
**Пояснення чому небезпечна** 
Модуль random не є криптографічно стійким — значення можна передбачити, особливо якщо відомо час створення (timestamp).

**Потенційний вплив**
Можливість передбачити або підробити booking code => ризик несанкціонованого доступу, дублювання або зміни бронювання.

| Поле | Пояснення |
|---|---|
| **Fault** | Функція `generate_booking_code()` використовує `random.randint()` і `time.time()`, які не є криптографічно стійкими. |
| **Error** | Генеровані коди можна передбачити, якщо відомо час створення; низька ентропія та повторюваність. |
| **Failure** | Зловмисник може підробити або вгадати код бронювання; несанкціонований доступ або дублювання даних. |
| **Severity** | Висока |